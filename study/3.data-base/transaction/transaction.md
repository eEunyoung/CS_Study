## 트랜잭션 관리와 무결성

### 트랜잭션 개념
#### 트랜잭션(transaction)이란?
> **DB의 나누어지지 않는 최소한의 처리 단위** <br>

#### 트랜잭션 종류
- COMMIT
  - 모든 작업들이 정상적으로 처리되었다고 확정하는 명령어로 처리과정을 DB에 영구저장하는 것이다.
  - Commit을 수행하면 이전 데이터가 완전히 UPDATE 된다.
- ROLLBACK
  - 작업 중 문제가 발생된 트랜잭션의 처리과정에서 발생한 변경사항을 취소하는 명령어이다.
  - 트랜잭션이 시작되기 이전의 상태로 되돌린다. 즉, 마지막 커밋을 완료한 시점으로 다시 되돌아간다.
  - 트랜잭션은 All or Nothing 방식으로 DML 명령어들을 처리한다.
 
#### 트랜잭션 작동 원리 (생명주기) <br>
<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FQ2V31%2Fbtr2sWO3f50%2FyEz1vGCsYmKs9ao4Vnj8KK%2Fimg.png" width="70%"/> <br>
- 활성화 (Activate)
  - 트랜잭션 실행 중 첫 상태이다.
  - 트랜잭션은 명령이 수행되는 동안 활성화된다.
- 부분 커밋 (Partially Committed)
  - 변경이 실행되었지만 데이터베이스는 아직 디스크에서 변경을 커밋하지않았다.
  - 데이터는 메모리 버퍼에만 저장되며 버퍼는 아직 디스크에 기록되지 않았다.
  - 중간에 실패할 수 있다. 
- 커밋 (Committed)
  - 이 상태에서는 모든 트랜잭션 업데이터가 데이터베이스에 영구적으로 저장된다.
  - 이 시점 이후에는 롤백할 수 없다.
- 실패 (Failed)
  - 트랜잭션이 실패하거나 활성 또는 일부만 커밋된 상태에서 중단된 경우 실패 상태가 된다.
- 종료 (Terminated)
  - 커밋되거나 이후의 중단됨(Aborted) 상태 이후의 마지막 상태이다.
  - 트랜잭션의 생명주기를 끝으로 표시한다.

### 트랜잭션 특성
#### ACID
- Atomicity
  - 원자성
  - All or Nothing
  - 모든 작업이 실행되거나, 혹은 모든 작업이 실행되지 않아야한다.
- Consistency
  - 일관성
  - 데이터베이스의 상태과 일관되어야 한다는 성질
  - 모든 트랜잭션이 종료된 후에 DB의 제약 조건을 모두 지키고 있는 상태가 되어야 한다.
- Isolation
  - 격리성, 고립성
  - 트랜잭션 A와 다른 트랜잭션들은 독립적으로 동작해야 한다.
  - 서로의 작업을 알지 못하는 상태여야 한다.
    > 📌 완전한 격리성을 지향해서 설계를 하면 안정성 측면에서는 가장 좋지만 성능은 떨어지게 된다.
    >    - 동시성 처리에 대한 성능이 떨어진다.
    >    - DeadLock이 발생할 확률이 높다
    >    - Lock으로 인한 시스템 오버헤드가 증가한다
    >    - DBMS는 MVCC을 구현하거나 Lock을 사용해야 한다. <br>
- Durability
  - 지속성
  - 하나의 트랜잭션이 성공적으로 수행되었다면, 해당 트랜잭션에 대한 로그가 남아야 한다는 성질을 말한다.
  - 트랜잭션 커밋 후 , 데이터베이스에 영구적으로 보존되어야 한다.

#### 트랜잭션의 격리 수준(Transaction Isolation Level)이란?
  특정 트랜잭션이 다른 트랜잭션에서 변경하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것으로, 즉 격리 수준을 결정하는 행위는 각 트랜잭션의 격리 정도를 결정하여 안정성과 성능의 균형을 결정하는 행위라고 할 수 있다.
  - 트랜잭션 격리 수준 종류
    - READ_UNCOMMITTED
      - 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 값을 읽을 수 있도록 하는 격리 수준이다.
      - 성능이 가장 좋은 방식이나, 안정성이 가장 떨어지는 방식으로 DIRTY READ 현상이 발생할 가능성이 크다. <br>
         ※DIRTY READ 란? 특정 트랜잭션이 진행 중일 때 다른 트랜잭션에서 접근 하도록 열어두는 것으로 일관성이 맞지 않는 결과를 도출한다.
      - 권장되지 않는 방식
      <img src = "https://velog.velcdn.com/images/chiyongs/post/1e5bf034-d244-497c-b349-340d9e88e384/image.png" width = "70%"/>
    - READ_COMMITTED
      - 각 트랜잭션에서의 변경 내용이 성공적으로 마무리되어 COMMIT 이되어야 하는 다른 트랜잭션이 접근 가능하도록 하는 격리 수준이다.
      - 대표적으로 Oracle DB에서 사용하고 있는 수준이며 가장 많이 사용되고 있다.
      - DIRTY READ 현상이 발생하지 않는다.
      - 커밋하기 전 다른 트랜잭션에서 조회시 UNDO 영역의 백업된 레코드에서 결과를 가져온다.
      - NON_REPEATABLE READ 문제가 발생할 수 있다.
    - *_NON_REPEATABLE READ_*
      - 한 트랜잭션 안에 똑같은 READ를 실행했을 때 항상 같은 결과를 가져오지 않는 현상이다.
      - Lock을 통해 동시성을 제어하는 방식에서는 Select 쿼리 실행 시 Read Lock을 획득하지 않거나, 획득한 Lock이 Select 쿼리를 실행하자마자 해제될 때 발생한다. <br>
      <img src = "https://velog.velcdn.com/images/chiyongs/post/a78d2b5e-618d-4de5-886c-653ed6dbef79/image.png" width = "70%"/> <br>
      - 해결 방법
        - Transactio A가 commit이나 rollback이 될 때까지 Transaction B의 실행을 지연하는 것이다.
        - Multiversion Concurrency Control(MVCC)을 사용한다. <br>
          > ✏️ MVCC(Multiversion Concurrency Control) 란? <br>
          > 다중 버전 동시성  제어의 약자로  DBMS에서 서로 다른 세션이 동일한 데이터에 접근했을 때 각 세션마다 스냅샷 이미지를 보장해주는 매커니즘이고 RDBMS에서 동시성을 높이기 위해 등장한 기술이다.
          > MVCC의 가장 큰 목적은 Lock을 사용하지 않는 일관된 읽기를 제공하기 위함이고, InnoDB에서는 Undo log를 이용하여 이 기능을 제공하고 있다. <br>
    - REPEATABLE_READ
      - 트랜잭션 범위 내에서 조회한 내용이 항상 동일함을 보장하는 트랜잭션 격리 수준이다.
      - MySQL의 InnoDB에서 기본으로 사용하는 트랜잭션 격리 수준이다.
      - Phantom Read 문제가 발생할 수 있다.
    - *_PHANTOM READ_*
      -  다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상이다.
      -  NON_REPEATABLE READ의 경우 중 하나이며 , Transaction A가 범위를 조회하는 쿼리를 반복적으로 사용할 때, 그 쿼리들 사이에서 Transaction B가 해당 쿼리를 만족하는 새로운 행을 생성했을 때 발생한다.
      -  InnoDB는 index-row locking 과 gap locking을 섞은 next-key locking 알고리즘을 사용하고 있어 Repeatable Read에서도 Phantom Read를 예방할 수 있다.
      <img src = "https://velog.velcdn.com/images/chiyongs/post/3ac94f8c-8321-41af-97b7-c25ebd652ee3/image.png" width = "70%"/>
    - SERIALIZABLE
      - 모든 작업을 하나의 트랜잭션에서 처리하는 것과 같이 동작하는 가장 높은 트랜잭션 격리 수준이다.
      - 한 트랜잭션에서 읽고 쓰는 레코드는 다른 트랜잭션에서 절대 접근할 수 없습니다.
      - PHANTOM READ 문제는 발생하지 않는다.
      - DeadLock에 걸릴 가능성이 존재하고 동시성 처리 성능이 저하되기 떄문에 신중하게 사용해야 한다. 

<br><br>
===
<br>

### 동시성 제어
#### 동시성 제어란?
> **DBMS가 다수의 사용자 사이에서 동시에 작용하는 다중 트랜잭션의 상호간섭작용에서 Database를 보호하는 것을 의미한다.** <br>
<img src = "https://velog.velcdn.com/images/choidongkuen/post/bbac64f0-1b91-4b1c-89d9-16974323e3a8/image.png" width = "70%"/> <br>
한번에 들어온 복수의 트랜잭션을 직렬화 하는 수행을 보장한다. <br>

#### 동시성 제어의 목적
- 트랜잭션의 직렬성 보장, 동시 수행 트랜잭션 처리량 최대화
- 공유도 최대, 응답 시간 최소, 시스템 활동의 최대 보장
- 데이터의 무결성 및 일관성 보장

#### 동시성 제어의 기준
- 트랜잭션 스케줄
  - 각 트랜잭션을 구성하는 연산들이 시스템에서 시간에 따라 실행되는 순서
- 직렬성(Serializability)
  - 트랜잭션들을 병행 처리한 결과가 트랜잭션들을 순차적(직렬)으로 수행한 결과와 같아지는 성질

#### 동시성 제어 기법 종류
- Locking
  - 정의
    - 하나의 트랜잭션이 실행하는 동안 특정 데이터 항목에 대해서 다른 트랜잭션이 동시에 접근하지 못하도록 상호배제 기능을 제공하는 기법이다.
    - 하나의 트랜잭션이 데이터 항목에 대하여 잠금(lock)을 설정하면, 잠금을 설정하는 트랜잭션이 해재(unlock)할 때까지 데이터를 독점적으로 사용할 수 있다.
  - locking 종류 (비관적 락)
    - Shared Lock (공유 락)
      - 사용중인 데이터에 대해서 다른 트랜잭션이 읽기가 가능하나 쓰기는 불가능하다.
      - 읽기 작업끼리는 서로 영향을 주지 않으므로 또 다른 트랜잭션도 공유락이 설정된 데이터에 대해서 공유락 설정이 가능하다.
    - Exclusive Lock (베타 락)
      - 사용중인 데이터에 대해서 다른 트랜잭션이 읽기, 쓰기가 불가능하다.
      - 다른 트랜잭션은 배타락이 설정된 데이터에 대해서 어떤 lock도 설정이 불가능하다. 
  - JPA에서의 버전 관리 (낙관적 락)
    - 데이터 갱신 시 충돌이 발생하지 않을 것으로 가정하여 락이 아닌 버전 관리 기능을 통해서 트랜잭션 격리성 관리하고 충돌을 방지한다.
    - DB가 제공하는 락 기능을 사용하지 않고 JPA가 제공하는 버전 관리 기능을 사용한다. (어플리케이션 단위의 락)
    - 커밋 전까지는 충돌을 알 수 없다.
    - 충돌이 나면 롤백 처리는 개발자의 몫이다.
  > 수정 비율이 높다면 비관적 락, 읽기 비중이 높다면 낙관적 락 사용 <br> 
- 2 Phase Locking
  - locking 단계를 2개로 구분하여 lock과 unlock하는 시간을 구분하여 동시성 제어한다.
  - 직렬 가능성을 보장할 수 있는 규약으로 많이 사용되지만, 교착 상태, 연쇄복귀문제가 발생할 가능성이 있다.
  - lock 연산의 대상은 속성->튜플->릴레이션->데이터베이스 순으로 커질수록 lock의 수가 적어지고 제어가 간단하지만 병행성이 떨어지는 단점이 있다. (locking 단위가 작을 수록 구현은 복잡하지만 lock의 수, 제어기법이 복잡하여도 병행성이 높다)
  - 확장 단계
    - 트랜잭션은 새로운 lock O, unlock X
  - 축소 단계
    - 트랜잭션은 새로운 lock X, unlock O
  - 엄격한 2단계 잠금 규약
    - 2단계 잠금 규약에서 발생하는 연쇄복귀 문제를 해결한다.
- Timestamp Ordering
  - DBMS가 부여하는 유일한 식별자인 타임 스탬프(시스템에 들어오는 순서)를 지정하여 트랜잭션 간의 순서를 미리 선택하여 직렬화 하는 방법이다.
  - 교착 상태를 방지할 수 있지만 rollback 발생률이 높고 연쇄 복귀 문제 초래 가능성이 있다.
  - TimeStamp 생성 기법
    - 논리적 계수기 (Logical Count)
      - 트랜잭션 발생시 카운터가 증가한다.
    - 시스템 클럭 (System Clock)
      - 트랜잭션이 시스템이 들어올 때의 시스템 시각이 부여된다.
- Validation(낙관적 검증) <br>
  <img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdd73C8%2FbtrJ1YqUCRN%2F2HHa14PB41bUxzUjfkYIAk%2Fimg.png" width="60%"> <br>
  - 데이터 갱신 시 충돌이 발생하지 않을 것으로 가정하여 락을 걸지 않으며 트랜잭션 수행 동안은 검사하지 않고 트랜잭션 종료시 일괄적으로 검사하는 방법이다.
  - 트랜잭션 수행 동안은 트랜잭션을 위해 유지되는 데이터 항목들의 지역 사본에 대해서만 갱신한다.
  - 트랜잭션 종료 시에 동시성을 위한 트랜잭션 직렬화 검증이 되면 일시에 DB에 반영한다.
- MVCC(다중버전 동시성 제어)
  - 트랜잭션의 타임스탬프와 접근 데이터의 여러 버전 타임 스탬프를 비교하여 직렬 가능성이 보장되는 버전 선택한다.
  - 하나의 데이터 아이템에 대해 여러 버전의 값을 유지한다.
  - 기록보다는 판독 연산이 주류를 이루는 데이터 베이스 시스템에 유리하다.
  - 데이터 아이템을 판독할 때마다 중복되는 디스크 접근한다.
  - 트랜잭션 간의 충돌 문제는 대기가 아니라 복귀 처리한다. -> 연쇄 복귀 문제 발생 가능성이 있다.

> MVCC 대신 락을 사용하는 이유? <br>
> 낙관적인 락이나 비관적인 락은 다른 트랜잭션의 쓰기 작업 자체를 막아버리지만 MVCC는 레코드에 잠금을 걸지 않고 트랜잭션 격리 레벨에 따라 Undo 로그에서 데이터를 가져와 일관된 읽기를 제공하기 때문에 두 트랜잭션이 동시 수정 작업시 처음의 수정사항만 반영되도록 하여 갱신 분실 문제를 에방하기 위해서는 락을 사용한다.

  
#### 동시성 제어 하지 않을 경우 문제점
- 갱신 손실 (Lost Update)
  - 하나의 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효화 되는 것을 의미한다,
  - 두 개이상 트랜잭션이 한 개의 데이터를동시에 갱신할 때 발생한다.
- 현황파악 오류 (Dirty Read)
  - 읽기 작업을 하는 트랜잭션 1이 쓰기 작업을 하는 트랜잭션 2가 작업한 중간 데이터를 읽기 때문에 발생하는 문제이다.
  - 작업중인 트랜잭션 2가 작업을 rollback한 경우 트랜잭션 1은 무효가 된 데이터를 읽게 되고 잘못된 결과를 도출한다.
- 모순성 (Inconsistency)
  - 다른 트랜잭션들이 해당 항목 값을 갱신하는 동안 한 트랜잭션이 두 개의 항목 값 중 어떤 것은 갱신되기 전의 값을 읽고 다른 것은 갱신된 후의 값을 읽게 되어 데이터 불일치가 발생하는 상황이다.
- 연쇄 복귀 (Cascading Rollback)
  -  두 트랜잭션이 동일한 데이터 내용을 접근할 때 발생한다.
  -  한 트랜잭션이 데이터를 갱신한 다음 실패하여 rollback 연산을 수행하는 과정에서 갱신과 rollback 연산을 실행하고 있는 사이에 해당 데이터를 읽어서 사용할 때 발생할 수 있는 문제이다.

📌 동시성 제어 기법 추가 참고 내용 : <a href="https://velog.io/@ha0kim/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4" >동시성제어</a>

<br><br>
===
<br>

### 장애와 회복
#### 장애
> **트랜잭션을 더 이상 수행할 수 없는 시스템 중단상태를 의미한다.** <br>
- 종류
  - 실행 장애
    - 데이터베이스 연산 실패 
  - 트랜잭션 장애
    - 프로그램 실행 중지 
  - 시스템 장애
    - 하드웨어 결함
  - 미디어 장애
    - 디스크 장치 결함 

#### 회복
> **장애로 인해 제대로 실행되지 못한 DB를 이전 상태로 복구하는 작업이다.** <br>
- 종류
  - 덤프(Dump)
    - 주기적으로 데이터베이스 전체를 다른 저장장치에 복제하는 것이다.  
  - 로그(Log)
    - 데이터베이스가 변경될 때마다 예전값과 변경값을 기록해 두는 것이다. 
  - 재실행(Redo)
    - 장애 발생 전, 이미 완료된 트랜잭션을 재실행한다.
  - 취소(Undo)
    - 장애 발생 후, 진행 중이던 트랜잭션을 취소하고 이전 상태로 복구한다. 
- 회복 작업을 위해서는 덤프와 로그가 있어야만 가능하다. (Redo)
  - 장애 발생 시, 가장 최근의 복사본(덤프)을 가져 온 후 로그를 보며 복구한다. 복사본에는 반영되지 않았지만, 로그상으로 완료된 트랜잭션은 재실행해서 DB에 반영한다.
- 복사본에 장애 발생 후 진행 중이던 트랜잭션이 있다면, 반대로 로그를 보며 취소 작업을 실시한다. (Undo)

#### 회복 작업에서의 트랜잭션 (원자성과 영속성) <br>
<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FEb6YL%2FbtscAp0PsH7%2FwhbCuGYs1qcERBnKUTAXZ0%2Fimg.png" width="50%"/> <br>
장애 발생 시점을 기준으로 트랜잭션 완료 여부에 따라 Redo와 Undo로 나누어진다.
- Redo를 하는 이유
  - 트랜잭션의 영속성을 만족하기 위해서 이다.
  - 트랜잭션은 일단 완료되면 그 결과를 영구 기억장치에 저장하고 보존해야한다. 이를 위해 다시 Redo 작업을 실시해서 저장한다. 
- Undo를 하는 이유
  - 트랜잭션은 전부 실행되거나, 아예 실행되지 않아야 한다. 장애로 인해 중간 결과만 남은 경우, 다시 실행 이전으로 복구해야 한다.  

#### 데이터베이스 회복 작업
- 즉시 갱신
  > 트랜잭션 실행 중 변경내역을 DB에 즉시 반영하는 방식이다.
- 지연 갱신
  > 트랜잭션이 부분 완료될 때까지 (commit만 남겨둘 때까지) DB 반영을 지연시키는 방식
  <br>

> **출처** <br>
> <a href="https://velog.io/@wonizizi99/CS-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-Transaction">트랜잭션이란,  트랜잭션 종류</a><br>
> <a href="https://puleugo.tistory.com/142">트랜잭션 작동 원리</a><br>
> <a href="https://velog.io/@choidongkuen/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction-%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B4%85%EC%8B%9C%EB%8B%A4">ACID, 트랜잭션격리성수준</a><br>
> <a href="https://velog.io/@chiyongs/Transaction-Isolation-Level-%EA%B7%B8%EA%B2%8C-%EB%AD%94%EB%8D%B0">트랜잭션격리성수준</a><br>
> <a href="https://sabarada.tistory.com/121">Lock</a><br>
> <a href="https://dodop-blog.tistory.com/m/380">동시성 제어</a><br>
> <a href="https://velog.io/@choidongkuen/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4Concurrency-Controll">동시성 제어 문제점</a><br>
> <a href="https://star7sss.tistory.com/824">장애, 회복</a><br>
