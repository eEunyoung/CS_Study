**복합체 패턴(Composite Pattern)**
----
> 복합 객체(Composite) 와 단일 객체(Leaf)를 동일한 컴포넌트로 취급하여, 클라이언트에게 이 둘을 구분하지 않고 동일한 인터페이스를 사용하도록 하는 구조 패턴
<br>

**복합체 패턴 구조**
<img src = "https://t1.daumcdn.net/cfile/tistory/9959CC495C8910EB0F">
1. Component (인터페이스)
   * Leaf(단순 객체)와 Composite(복합 객체)를 묶는 공통적인 상위 인터페이스이다.
2. Composite
   * 복합 객체로서, Leaf 역할이나 Composite 역할을 넣어 관리하는 역할을 한다.
   * 자녀들의 구상 클래스들을 알지 못하며, 컴포넌트 인터페이스를 통해서만 모든 하위요소들과 함께 동작한다.
   * 요청을 전달받으면 컨테이너는 작업을 하위 요소들에 위임하고 중간 결과들을 처리한 다음 최종 결과들을 클라이언트에 반환한다.
   * Component 구현체들을 내부 리스트로 관리한다.
   * add와 remove 메소드는 내부 리스트에 단일/복합 객체를 저장한다.
   * Component 인터페이스의 구현 메서드인 operation은 복합 객체에서 호출되면 재귀하여, 추가 단일 객체를 저장한 하위 복합 객체를 순회하게 된다.
3. Leaf (컴포넌트)
   * 단일 객체로서, 단순하게 내용물을 표시하는 역할을 한다.
   * 트리의 기본 요소이며, 하위 요소가 없다.
   * 작업을 위임할 하위요소가 없어서 대부분의 실제 작업들을 수행한다.
   * Component 인터페이스의 구현 메서드인 operation은 단일 객체에서 호출되면 적절한 값만 반환한다.
4. Client
   * 컴포넌트 인터페이스를 통해 모든 요소들과 작동한다. 
   * 그 결과 트리의 단순/복합 객체들 모두에 대해 같은 방식으로 작업할 수 있다.

> **복합체 패턴의 핵심**<br>
> Composite와 Leaf가 동시에 구현하는 operation() 인터페이스 추상 메서드를 정의하고, Composite 객체의 operation() 메서드는 자기 자신을 호출하는 재귀 형태로 구현하는 것이다. 
<br>

**복합체 패턴 적용** <br>
1. 나무와 같은 객체 구조를 구현해야 하는 경우 (데이터를 다룰 때 계층적 트리 표현을 다루어야하는 경우)
   * 복합체 패턴은 공통 인터페이스를 공유하는 두 가지 기본 요소 유형들인 단순 잎들과 복합 컨테이너들을 제공한다.
   * 컨테이너는 잎들과 다른 컨테이너들로 구성될 수 있으며, 이를 통해 나무와 유사한 중첩된 재귀 객체 구조를 구성할 수 있다.
2. 클라이언트 코드가 단순/복합 객체들을 모두 균일하게 처리하도록 하고 싶은 경우
   * 복합체 패턴에 의해 정의된 모든 요소들은 공통 인터페이스를 공유하며, 이 인터페이스를 사용하면 클라이언트는 작업하는 객체들의 구상 클래스에 대해 걱정할 필요가 없다.
  
<br>

**복합체 패턴의 장점** <br>
1. 다형성과 재귀를 유리하게 사용해 복잡한 트리 구조들과 더 편리하게 작업할 수 있다.
2. 단일 객체와 복합 객체를 동일하게 여기기 때문에 묶어서 연산하거나 관리할 때 편리하다.
3. 수평적, 수직적 모든 방향으로 객체를 확장할 수 있다.
4. 개방/폐쇄 원칙 준수 (OCP)
   * 새로운 Leaf 클래스를 추가하더라도 클라이언트는 추상화된 인터페이스 만을 바라본다.
  
<br>

**복합체 패턴의 단점** <br>
1. 재귀 호출 특징 상 트리의 깊이가 깊어질 수록 디버깅에 어려움이 생긴다.
2. 설계가 지나치게 범용성을 갖기 때문에 새로운 요소를 추가할 때 복합 객체에서 구성 요소에 제약을 갖기 힘들다.
3. 계층형 구조에서 leaf 객체와 composite 객체들을 모두 동일한 인터페이스로 다루어야하는데, 이 공통 인터페이스 설계가 까다로울 수 있다.
   * 복합 객체가 가지는 부분 객체의 종류를 제한할 필요가 있을 경우
   * 수평적 방향으로만 확장이 가능하도록 Leaf을 제한하는 Composite를 만들 경우
  

<br>

**복합 패턴(복합체 패턴 + OO패턴)** <br>
1. 빌더 패턴
   * 빌더의 생성 단계들을 재귀적으로 작동하도록 프로그래밍 할 수 있다.
2. 책임 연쇄 패턴
   * 잎 컴포넌트가 요청을 받으면 해당 요청을 모든 부모 컴포넌트들의 체인을 통해 객체 트리의 root까지 전달할 수 있다.
3. 반복자 패턴
   * 복합체 패턴 트리들을 순회할 수 있다.
4. 비지터 패턴
   * 복합체 패턴 트리 전체를 대상으로 작업을 수행할 수 있다.
   
<br>

**복합체패턴과 데코레이터패턴의 유사성과 차이점** <br>
1. 유사성
   * 재귀적인 합성에 의존하여 하나 도는 불특정 다수의 객체들을 정리하기 때문에 구조 다이어그램이 유사하다.
   * 데코레이터 패턴
   <img src = "https://minsone.github.io/image/2015/Decorator_UML.png">
2. 차이점
   * 데코레이터는 자식 컴포넌트가 하나만 있다.
   * 데코레이터는 래핑된 객체에 추가 책임들을 추가하는 반면 복합체 패턴은 자신의 자식들의 결과를 요약하기만 한다.
3. 데코레이터를 사용하여 복합체 패턴 트리의 특정 객체의 행동을 확장할 수 있다.
